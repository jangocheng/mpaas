# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
asyncChannelGroup.createFail=无法为WebSocket客户端创建专用的异步通道组，这是防止复杂类加载程序环境（如JavaEE容器）中内存泄漏所必需的
asyncChannelWrapperSecure.check.notOk=TLS握手返回意外状态[{0}]
asyncChannelWrapperSecure.check.unwrap=在读取期间将字节写入输出
asyncChannelWrapperSecure.closeFail=干净的关闭通道失败
asyncChannelWrapperSecure.eof=意外的流结尾
asyncChannelWrapperSecure.statusUnwrap=unwrap()操作后SSLEngineResult 的意外状态
backgroundProcessManager.processFailed=后台进程失败
caseInsensitiveKeyMap.nullKey=不允许 Key 是 Null
perMessageDeflate.alreadyClosed=转换器已经关闭且可能永远不会使用
perMessageDeflate.deflateFailed=无法压缩这个WebSocket压缩结构
perMessageDeflate.duplicateParameter=重复定义的扩展参数[{0}]
perMessageDeflate.invalidWindowSize=为[{0}]指定了[{1}]大小的无效窗口。 有效值是从8到15（包括8和15）的整数。
util.invalidType=无法强制值[{0}]转为[{1}]类型（不支持次类型）。
util.notToken=一个非法的扩展参数被指定为名称[{0}]和值[{0}]
util.unknownDecoderType=无法识别该解码器类型[{0}]
wsFrame.alreadySuspended=消息接收已挂起。
wsFrame.byteToLongFail=提供了太多字节([{0}])，转换成一个长的字节。
wsFrame.closed=在一个关闭的控制帧后受到了一个新的帧.
wsFrame.controlFragmented=接收到分段的控制帧，但控制帧可能不被分割。
wsFrame.controlNoFin=发送一个没有设置的控制帧。控制帧不允许使用连续帧。
wsFrame.controlPayloadTooBig=以大于125字节的最大允许值的大小[{0}]的有效载荷发送控制帧。
wsFrame.illegalReadState=意外的读状态[{0}]
wsFrame.invalidUtf8Close=接收到一个WebSocket关闭帧，其关闭原因包含无效的UTF-8字节序列
wsFrame.notMasked=客户端帧未被屏蔽，但必须屏蔽所有客户端帧
wsFrame.partialHeaderComplete=接收到WebSocket帧. fin [{0}], rsv [{1}], OpCode [{2}], payload 长度 [{3}]
wsFrame.sessionClosed=无法处理客户端数据，因为会话已被关闭
wsFrame.textMessageTooBig=解码的文本消息对于输出缓冲区太大，终结点不支持部分消息
wsFrame.wrongRsv=对于具有opCode [{1}]的消息，客户端帧将保留位设置为[{0}]，此端点不支持
wsHandshakeRequest.invalidUri=字符串  [{0}] 不能用来组成一个有效的URI
wsHandshakeRequest.unknownScheme=请求中的计划[{0}]未识别
wsRemoteEndpoint.acquireTimeout=当前消息没有在指定的超时内完全发送
wsRemoteEndpoint.changeType=发送分段消息时，所有片段必须是相同类型的。
wsRemoteEndpoint.closed=由于 WebSocket session 已关闭，消息将不会被发送
wsRemoteEndpoint.closedDuringMessage=因为 WebSocket session 被关闭，消息的剩余部分将不会被送达
wsRemoteEndpoint.closedOutputStream=由于OutputStream已关闭，不应该调用此方法。
wsRemoteEndpoint.flushOnCloseFailed=会话关闭后仍然启用批处理消息。无法刷新剩余的批量消息
wsRemoteEndpoint.noEncoder=没有为类 [{0}] 的对象指定编码器
wsRemoteEndpoint.nullData=无效空的data 参数
wsRemoteEndpoint.sendInterrupt=当前线程在等待阻塞发送完成时被中断
wsRemoteEndpoint.tooMuchData=ping或pong不应该发送超过125字节
wsRemoteEndpoint.wrongState=远程 endpoint 处于 [{0}] 状态，是被调用方法的无效状态
wsSession.closed=WebSocket会话[{0}]已关闭，并且在关闭的会话上不能调用任何方法（除了close（））
wsSession.created=创建WebSocket session [{0}]。
wsSession.doClose=关闭 WebSocket session [{1}]
wsSession.duplicateHandlerPong=已经配置了pong消息处理器
wsSession.duplicateHandlerText=已配置文本消息处理器
wsSession.instanceNew=endpoint 实例注册失败
wsSession.sendCloseFail=给远程端点发送关闭消息失败，session：[{0}]
wsSession.unknownHandler=无法添加消息处理程序[{0}]，因为它是针对无法识别的类型[{1}]
wsWebSocketContainer.asynchronousSocketChannelFail=无法打开与服务器的连接
wsWebSocketContainer.failedAuthentication=无法处理http响应代码[{0}]。服务器不接受身份验证头。
wsWebSocketContainer.invalidExtensionParameters=服务器用客户端无法支持的扩展参数响应
wsWebSocketContainer.missingAnnotation=无法使用POJO类[{0}]，因为它未添加注解@ClientEndpoint
wsWebSocketContainer.missingLocationHeader=处理HTTP响应码 [{0}] 失败。响应头缺少Location
wsWebSocketContainer.missingWWWAuthenticateHeader=无法处理HTTP响应代码[{0}]。 缺少WWW-Authenticate标头作为响应
wsWebSocketContainer.pathNoHost=URI中未指定主机
wsWebSocketContainer.proxyConnectFail=失败连接到已配置的代理 [{0}]。HTTP 响应码是 [{1}]
wsWebSocketContainer.sessionCloseFail=ID 为 [{0}] 的session 没有彻底关闭
wsWebSocketContainer.shutdown=web应用程序正在停止
wsWebSocketContainer.sslEngineFail=无法创建SSLEngine以支持SSL/TLS连接
wsWebSocketContainer.unsupportedAuthScheme=HTTP响应码处理失败[{0}]. Unsupported Authentication 方案 [{1}] 返回到响应
#ghost.framework.websocket.plugin.server
serverContainer.configuratorFail=无法为[{1}]类型的POJO创建类型[{0}]的配置程序
serverContainer.duplicatePaths=多个端点可能不能发不到同一个路径[{0}]：已经存在的端点[{1}]和新的端点[{2}]
serverContainer.encoderFail=无法创建[{0}]类型的编码器
serverContainer.failedDeployment=由于以前的部署失败，不允许将WebSocket终结点部署到主机[{1}]中路径为[{0}]的Web应用程序
serverContainer.servletContextMissing=没有指定ServletContext
upgradeUtil.incompatibleRsv=指定扩展名具有不兼容的RSV位使用
uriTemplate.invalidPath=路径 [{0}] 无效。
wsFrameServer.bytesRead=将[{0}]个字节读入输入缓冲区，准备进行处理
wsFrameServer.onDataAvailable=进入方法
wsHttpUpgradeHandler.noPreInit=在容器调用init()之前，必须调用preinit()方法来配置WebSocket HttpUpgradeHandler。通常，这意味着创建WsHttpUpgradeHandler 实例的servlet也应该调用preinit()
wsRemoteEndpointServer.closeFailed=无法完全关闭ServletOutputStream 连接
#ghost.framework.websocket.plugin.util.threads
threadPoolExecutor.threadStoppedToAvoidPotentialLeak=停止线程[{0}]，从而避免context停止后的潜在的内存泄漏


